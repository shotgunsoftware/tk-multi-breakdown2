# Copyright (c) 2021 Autodesk, Inc.
#
# CONFIDENTIAL AND PROPRIETARY
#
# This work is provided "AS IS" and subject to the Shotgun Pipeline Toolkit
# Source Code License included in this distribution package. See LICENSE.
# By accessing, using, copying or modifying this work you indicate your
# agreement to the Shotgun Pipeline Toolkit Source Code License. All rights
# not expressly granted therein are reserved by Autodesk, Inc.

import os
import sgtk


HookBaseClass = sgtk.get_hook_baseclass()


class BreakdownSceneOperations(HookBaseClass):
    """A hook to perform scene operations in VRED necessary for Breakdown 2 App."""

    def __init__(self, *args, **kwargs):
        """Class constructor."""

        super(BreakdownSceneOperations, self).__init__(*args, **kwargs)

        self._vredpy = self.parent.engine.vredpy

        # Keep track of the scene change callbacks that are registered, so that they can be
        # disconnected at a later time.
        self._on_references_changed_cb = None
        self._on_metadata_chanaged_cb = None
        self._on_materials_changed_cb = None

    # ----------------------------------------------------------------------------------------
    # Properties

    @property
    def vredpy(self):
        """Get the VRED API module."""
        return self.parent.engine.vredpy

    # ----------------------------------------------------------------------------------------
    # Public methods

    def scan_scene(self):
        """
        The scan scene method is executed once at startup and its purpose is
        to analyze the current scene and return a list of references that are
        to be potentially operated on.

        The return data structure is a list of dictionaries. Each scene reference
        that is returned should be represented by a dictionary with three keys:

        - "node_name": The name of the 'node' that is to be operated on. Most DCCs have
          a concept of a node, path or some other way to address a particular
          object in the scene.
        - "node_type": The object type that this is. This is later passed to the
          update method so that it knows how to handle the object.
        - "path": Path on disk to the referenced object.
        - "extra_data": Optional key to pass some extra data to the update method
          in case we'd like to access them when updating the nodes.

        Toolkit will scan the list of items, see if any of the objects matches
        a published file and try to determine if there is a more recent version
        available. Any such versions are then displayed in the UI as out of date.
        """

        refs = []

        for r in self.vredpy.vrReferenceService.getSceneReferences():

            # we only want to keep the top references
            has_parent = self.vredpy.vrReferenceService.getParentReferences(r)
            if has_parent:
                continue

            if r.hasSmartReference():
                node_type = "smart_reference"
                path = r.getSmartPath()
            elif r.hasSourceReference():
                node_type = "source_reference"
                path = r.getSourcePath()
            else:
                node_type = "reference"
                path = None

            if path:
                refs.append(
                    {
                        "node_name": r.getName(),
                        "node_type": node_type,
                        "path": path,
                        "extra_data": {"node_id": r.getObjectId()},
                    }
                )

        # Get Material Asset references
        material_nodes = self.vredpy.vrMaterialService.getMaterialNodes()
        for material_node in material_nodes:
            material = material_node.getMaterial()
            if material.isAsset():
                # Get file path from metadata
                metadata = self.vredpy.vrMetadataService.getMetadata(material)
                path_data = self.vredpy.get_metadata_value(metadata, "path") or {}
                path = path_data.get("local_path")
                if path:
                    refs.append(
                        {
                            "node_name": material.getName(),
                            "node_type": "material",
                            "path": path,
                            "extra_data": {
                                "node_id": material_node.getObjectId()
                            },
                        }
                    )

        return refs

    def update(self, item):
        """
        Perform replacements given a number of scene items passed from the app.

        Once a selection has been performed in the main UI and the user clicks
        the update button, this method is called.

        :param item: Dictionary on the same form as was generated by the scan_scene hook above.
                     The path key now holds the path that the node should be updated *to* rather than the current path.
        """

        node_type = item["node_type"]

        if node_type == "material":
            self._update_material_asset(item)
        else:
            self._update_reference(item)
        
    def register_scene_change_callback(self, scene_change_callback):
        """
        Register the callback such that it is executed on a scene change event.

        This hook method is useful to reload the breakdown data when the data in the scene has
        changed.

        For Alias, the callback is registered with the AliasEngine event watcher to be
        triggered on a PostRetrieve event (e.g. when a file is opened).

        :param scene_change_callback: The callback to register and execute on scene chagnes.
        :type scene_change_callback: function
        """

        # Keep track of the callback so that it can be disconnected later
        self._on_references_changed_cb = (
            lambda nodes=None, cb=scene_change_callback: cb()
        )
        self._on_metadata_chanaged_cb = lambda changes=None, cb=scene_change_callback: cb()
        self._on_materials_changed_cb = scene_change_callback

        # Set up the signal/slot connection to potentially call the scene change callback
        # based on how the references have cahnged.
        # NOTE ideally the VRED API would have signals for specific reference change events,
        # until then, any reference change will trigger a full reload of the app.
        if hasattr(self.vredpy, "vrScenegraphService"):
            self.vredpy.vrScenegraphService.scenegraphChanged.connect(
                self._on_references_changed_cb
            )
        else:
            self.vredpy.vrReferenceService.referencesChanged.connect(
                self._on_references_changed_cb
            )
        if hasattr(self.vredpy, "vrMaterialService"):
            self._on_materials_changed_cb = scene_change_callback
            self.vredpy.vrMaterialService.materialsChanged.connect(self._on_materials_changed_cb)
        if hasattr(self.vredpy, "vrMetadataService"):
            self._on_metadata_chanaged_cb = lambda changes=None, cb=scene_change_callback: cb()
            self.vredpy.vrMetadataService.metadataChanged.connect(self._on_metadata_chanaged_cb)
        

    def unregister_scene_change_callback(self):
        """Unregister the scene change callbacks by disconnecting any signals."""

        if self._on_references_changed_cb:
            if hasattr(self.vredpy, "vrScenegraphService"):
                try:
                    self.vredpy.vrScenegraphService.scenegraphChanged.disconnect(
                        self._on_references_changed_cb
                    )
                except RuntimeError:
                    # Signal was never connected
                    pass
                finally:
                    self._on_references_changed_cb = None
            else:
                try:
                    self.vredpy.vrReferenceService.referencesChanged.disconnect(
                        self._on_references_changed_cb
                    )
                except RuntimeError:
                    # Signal was never connected
                    pass
                    self._on_references_changed_cb = None

        if self._on_materials_changed_cb:
            try:
                self.vredpy.vrMaterialService.materialsChanged.disconnect(
                    self._on_materials_changed_cb
                )
            except RuntimeError:
                # Signal was never connected
                pass
            self._on_materials_changed_cb = None

        if self._on_metadata_chanaged_cb:
            try:
                self.vredpy.vrMetadataService.metadataChanged.disconnect(
                    self._on_metadata_chanaged_cb
                )
            except RuntimeError:
                # Signal was never connected
                pass
            self._on_metadata_chanaged_cb = None

    # ----------------------------------------------------------------------------------------
    # Protected methods

    def _get_reference_by_id(self, ref_id):
        """
        Get a reference node from its name.

        :param ref_name: Name of the reference we want to get the associated node from
        :returns: The reference node associated to the reference name
        """
        ref_list = self.vredpy.vrReferenceService.getSceneReferences()
        for r in ref_list:
            if r.getObjectId() == ref_id:
                return r
        return None

    def _update_reference(self, item):
        """Update the reference associated with the given item."""

        node_name = item["node_name"]
        node_type = item["node_type"]
        path = item["path"]
        extra_data = item["extra_data"]

        ref_node = self._get_reference_by_id(extra_data["node_id"])
        if not ref_node:
            self.logger.error("Couldn't get reference node named {}".format(node_name))
            return

        new_node_name = os.path.splitext(os.path.basename(path))[0]

        if node_type == "source_reference":
            ref_node.setSourcePath(path)
            ref_node.loadSourceReference()
            ref_node.setName(new_node_name)
        elif node_type == "smart_reference":
            ref_node.setSmartPath(path)
            self.vredpy.vrReferenceService.reimportSmartReferences([ref_node])

    def _update_material_asset(self, item):
        """Update the VRED Material Asset."""

        path = item["path"]
        old_path = item["extra_data"]["old_path"]

        # Load the new material asset
        name = self.vredpy.get_material_asset_name_from_path(path)
        material_v1 = self.vredpy.vrAssetsModule.loadMaterialAssetByName(name, path)
        # Convert to v2 material
        new_material = self.vredpy.get_material_v2(material_v1)

        metadata = {"path": {"local_path": old_path}}
        old_material = self.vredpy.find_material_by_metadata(metadata)
        nodes_to_update = self.vredpy.vrMaterialService.findNodesWithMaterial(old_material)
        if nodes_to_update:
            self.vredpy.vrMaterialService.applyMaterialToNodes(new_material, nodes_to_update)

        # Add metadata to material
        material_metadata = item["sg_data"].copy()
        self.vredpy.add_metadata_to_material(new_material, material_metadata)

        # Remove the old materials and their metadata
        self.vredpy.delete_material(old_material)
