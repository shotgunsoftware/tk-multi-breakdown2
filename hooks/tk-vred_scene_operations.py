# Copyright (c) 2020 Shotgun Software Inc.
#
# CONFIDENTIAL AND PROPRIETARY
#
# This work is provided "AS IS" and subject to the Shotgun Pipeline Toolkit
# Source Code License included in this distribution package. See LICENSE.
# By accessing, using, copying or modifying this work you indicate your
# agreement to the Shotgun Pipeline Toolkit Source Code License. All rights
# not expressly granted therein are reserved by Shotgun Software Inc.

import os
import sgtk

try:
    import builtins
except ImportError:
    import __builtins__ as builtins

import vrScenegraph
import vrFieldAccess
import vrFileIO
import vrNodePtr
builtins.vrNodeService = vrNodeService


HookBaseClass = sgtk.get_hook_baseclass()


class BreakdownSceneOperations(HookBaseClass):
    """
    """

    def scan_scene(self):
        """
        The scan scene method is executed once at startup and its purpose is
        to analyze the current scene and return a list of references that are
        to be potentially operated on.

        The return data structure is a list of dictionaries. Each scene reference
        that is returned should be represented by a dictionary with three keys:

        - "node_name": The name of the 'node' that is to be operated on. Most DCCs have
          a concept of a node, path or some other way to address a particular
          object in the scene.
        - "node_type": The object type that this is. This is later passed to the
          update method so that it knows how to handle the object.
        - "path": Path on disk to the referenced object.
        - "extra_data": Optional key to pass some extra data to the update method
          in case we'd like to access them when updating the nodes.

        Toolkit will scan the list of items, see if any of the objects matches
        a published file and try to determine if there is a more recent version
        available. Any such versions are then displayed in the UI as out of date.
        """

        refs = []

        for node in vrScenegraph.getAllNodes():
            path = None

            if node.hasAttachment("FileInfo"):
                path = vrFieldAccess.vrFieldAccess(
                    node.getAttachment("FileInfo")
                ).getString("filename")

            if path is not None:
                refs.append(
                    {"node_name": node.getName(), "node_type": node.getType(), "path": path}
                )

        refs = [dict(r) for r in {tuple(d.items()) for d in refs}]

        return refs

    def update(self, item):
        """
        Perform replacements given a number of scene items passed from the app.

        Once a selection has been performed in the main UI and the user clicks
        the update button, this method is called.

        :param item: Dictionary on the same form as was generated by the scan_scene hook above.
                     The path key now holds the path that the node should be updated *to* rather than the current path.
        """

        node_name = item["node_name"]
        node_type = item["node_type"]
        path = item["path"]

        # find all the nodes in the current scene regarding to their name
        nodes = vrScenegraph.findNodes(node_name)
        if len(nodes) <= 0:
            self.logger.debug("Couldn't find any nodes in the scene graph where name is {}.".format(node_name))
            return

        if node_type in ["Geometry", "ExtReference"]:
            # load the geometry only for the first node, but after that, try to clone this node to avoid importing
            # the file many times
            new_node = vrFileIO.loadGeometry(path)
            # we need to convert the root node to a vrNodeService in order to be able to use the Python API V2
            old_node = vrNodeService.getNodeFromId(nodes[0].getID())
            self._apply_transforms_and_materials(old_node, new_node)
            # once the new node is fully created, linked it to old node parent
            nodes[0].getParent().addChild(new_node)

            # deal with all the other references to the node
            for n in nodes[1:]:
                old_n = vrNodeService.getNodeFromId(n.getID())
                clone_node = new_node.clone()
                self._apply_transforms_and_materials(old_n, clone_node)
                n.getParent().addChild(clone_node)

            # finally, delete all the old nodes
            vrScenegraph.deleteNodes(nodes, True)

    def _apply_transforms_and_materials(self, old_root_node, new_node):
        """
        Get the transforms from the old node and apply them to the new node and its children

        :param old_node: Root of the node we want to get transforms and materials from
        :param new_node: Node we want to apply transforms and materials to
        """

        node_name = new_node.getName()

        # look in the old reference tree if we can find a node with the same name
        old_node = vrNodeService.findNode(node_name, wildcard=False, includeComponents=False, root=old_root_node)
        if old_node:
            # apply the transforms and the materials
            old_node_ptr = vrNodePtr.toNode(old_node.getObjectId())
            vrScenegraph.copyTransformation(old_node_ptr, new_node)
            node_material = old_node_ptr.getMaterial()
            if node_material.isValid():
                new_node.setMaterial(node_material)

        # recursively apply the transforms and materials to the node children too
        for i in range(0, new_node.getNChildren()):
            child_node = new_node.getChild(i)
            self._apply_transforms_and_materials(old_root_node, child_node)
